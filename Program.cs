// See https://aka.ms/new-console-template for more information

using System;
using System.IO; //For checking if directory provided is valid
using System.Diagnostics; //Stopwatch
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Numerics; //BigInteger
using System.Security.Cryptography; //RandomNumberGenerator
using System.Threading;
using System.Threading.Tasks;



class Program
{

    //Globals

    public class GlobalStrings{
        public static string expectedArgs = @"dotnet run <bits> <option> <count>
        - bits - the number of bits of the number to begenerated, this must
        be a multiple of 8, and at least 32bits.
        - option - 'odd' or'prime' (the type of numbers to be generated)
        - count - the count of numbers to generate, defaults to 1";
    }   


    static BigInteger GenerateBigInt(int bits){

        int byteSize = bits / 8;
        byte[] randomBytes = new byte[byteSize];

        using (RandomNumberGenerator rng = RandomNumberGenerator.Create()){ 
            rng.GetBytes(randomBytes);
        }

        //Testing
        // Console.WriteLine("Generated Bytes Original:");
        // foreach (byte b in randomBytes)
        // {
        //     Console.Write($"{b:X2} ");
        // }
        // Console.WriteLine();

        //Reverse Byte arr due to BigInteger assuming littleEndian
        Array.Reverse(randomBytes);

        // Console.WriteLine("Generated Bytes Reversed:");
        // foreach (byte b in randomBytes)
        // {
        //     Console.Write($"{b:X2} ");
        // }
        // Console.WriteLine();
        
        BigInteger randomBigInt = new BigInteger(randomBytes);
        

        if(randomBigInt < 0){
            randomBigInt = -randomBigInt;

        }
        return randomBigInt;

    }

    static async Task Main(string[] args)
    {

        if(args.Length > 1 && args.Length <= 3){
            ;
        }
        else{
            Console.WriteLine("Expected between 1 and 3 arguments (inclusive).");
            Console.WriteLine("\n" + GlobalStrings.expectedArgs + "\n");
            throw new ArgumentException("Invalid argument ammount provided.");
        }

        //Handling for Bits argument
        int bits = int.Parse(args[0]);

        bool throwBitExc = false;
        if(bits%8 != 0){
            Console.WriteLine("Expected multiple of 8 bits for bits argument.");
            throwBitExc = true;
        }
        if(bits < 32){
            Console.WriteLine("Expected bits value greater than 32.");
            throwBitExc = true;
        }
        if(throwBitExc){
            Console.WriteLine("\n" + GlobalStrings.expectedArgs + "\n");
            throw new ArgumentException("Provided bit value is invalid, see above messages.");
        }
        //Console.WriteLine("BitLength: " + bits);

        string opt = args[1].ToLower();
        //Console.WriteLine("Test: " + opt);

        if(opt != "odd" && opt != "prime"){
            Console.WriteLine("Expected values 'odd' or 'prime' for 2nd argument.");
            Console.WriteLine("\n" + GlobalStrings.expectedArgs + "\n");
            throw new ArgumentException("Provided option value does not match 'odd' or 'prime'.");
        }

        int count = 1; // Default to 1

        if (args.Length > 2 && !int.TryParse(args[2], out count))
        {
            Console.WriteLine("Expected number value for count.");
            Console.WriteLine("\n" + GlobalStrings.expectedArgs + "\n");
        }
        //Console.WriteLine($"Count is: {count}");

        List<Task> tasks = new List<Task>();

        if (opt == "odd"){

            Stopwatch stopwatch = new Stopwatch(); //

            stopwatch.Start(); 

            List<BigInteger> validNumbers = new List<BigInteger>();
            object lockObj = new object();

            int taskNum = 0;

            while (true)
            {
                tasks.Add(Task.Run(async () =>
                {
                    try
                    {
                        BigInteger val = GenerateBigInt(bits);

                        if (val % 2 == 1) // Ensure odd
                        {
                            lock (lockObj)
                            {
                                if (validNumbers.Count >= count) return; // Stop extra numbers
                                else {
                                    taskNum++;
                                    validNumbers.Add(val);
                                }
                                //Console.WriteLine($"validCount so far: {validNumbers.Count}");
                            }

                            await odd(val, bits, taskNum );
                            //Console.WriteLine($"Processed: {validNumbers.Count}, Val: {val}, Count: {count}");
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error: " + e);
                    }
                }));

                //taskNum++;

                await Task.Delay(20);

                if (validNumbers.Count >= count) break; // Stop loop when we have enough numbers
            }
            stopwatch.Stop(); 

            double elapsedSeconds = stopwatch.Elapsed.TotalSeconds; 
            Console.WriteLine("Time to Generate: " + elapsedSeconds);
        }

        else if(opt == "prime"){
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start(); 

            Console.WriteLine("In prime");
            // List<BigInteger> validNumbers = new List<BigInteger>();
            object lockObj = new object();


            while (true)
            {
                tasks.Add(Task.Run(async () =>
                {
                    try
                    {
                        BigInteger val = GenerateBigInt(bits);

                        if (val % 2 == 1) // Ensure odd
                        {
                            lock (lockObj)
                            {
                                // Console.WriteLine(primeTaskNum);
                                if (primeTaskNum >= count) return; // Stop extra numbers
                                // else {
                                //     validNumbers.Add(val);
                                // }
                                //Console.WriteLine($"validCount so far: {validNumbers.Count}");
                            }

                            await prime(val, bits);
                            
                            //Console.WriteLine($"Processed: {validNumbers.Count}, Val: {val}, Count: {count}");
                        }
                    }
                    catch (Exception e)
                    {
                        Console.WriteLine("Error: " + e);
                    }
                }));

                //taskNum++;

                await Task.Delay(20);

                if (primeTaskNum >= count) break; // Stop loop when we have enough numbers
            }
            stopwatch.Stop(); 

            double elapsedSeconds = stopwatch.Elapsed.TotalSeconds; 
            Console.WriteLine("Time to Generate: " + elapsedSeconds);
        }

        // Console.WriteLine(tasks.Count);
        // foreach( Task t in tasks){
        //     Console.WriteLine(t);
        // }

        await Task.WhenAll(tasks);
        Console.WriteLine("All tasks done");

  }

    public static async Task odd(BigInteger val, int bitLen, int valid){
        //Console.WriteLine("Odd on: " + val);



        //work
        //TEST System.Threading.Thread.Sleep(1500); 
        
        int factors = 1;
        BigInteger temp = val;

        if(temp > 1){

            //start @ 3 since odd, so no need for 2, i^2 is max cause root(i) is max factor
            for(BigInteger i = 3; i * i <= temp; i += 2){

                //tracker for same factor multiple times
                int exp = 0;

                //while remainder doesnt exists (even divisibility)
                while (temp % i == 0){
                    exp++; //add 1 to exp val
                    temp /= i; //divide, check for reminder
                }
                if(exp > 0){ //after division multiple times, add exponend to factor amt
                    //add to count all values that would be able to make the found factor
                    factors *= exp + 1;
                }
            }
        }

        if(temp > 1){ //acount for prime value
            factors *= 2;
        }


        Console.WriteLine("BitLength: " + bitLen);
        Console.WriteLine(valid + ": " + val);
        Console.WriteLine("Number of factors: " + factors);
        Console.WriteLine();

        await Task.CompletedTask;
    }


    public static int primeTaskNum = 0;

    public static async Task prime(BigInteger val, int bitLen){
        // Console.WriteLine("TEST1");

        //Used AI here to help solve a bug
        //C:\Users\blue3\Documents\CoPADS\NumGen\Program.cs(15,7): 
        //  error CS1106: Extension method must be defined in a 
        //  non-generic static class [filepath]
        //In turn, moved IsProbablyPrime() into its own class

        bool isProbPrime = await Task.Run(() => val.IsProbablyPrime());
        // Console.WriteLine(val + ": " + isProbPrime);
        //test print for return paths 
        //Console.WriteLine("iPP: " + isProbPrime + ": " + primeTaskNum);
        if(isProbPrime){

            int currentTaskNum = Interlocked.Increment(ref primeTaskNum);

            Console.WriteLine("BitLength: " + bitLen + " bits");
            Console.WriteLine(currentTaskNum + ": " + val);
            Console.WriteLine();
        }
    }
}

public static class PrimalityTestExtensions{
    //See function prime( ... ) for why this is moved here (bug fix)

    //Returns True is probably prime, false otherwise
    public static bool IsProbablyPrime( this BigInteger n, int k = 10){
        
        //Find S and D
        // Console.WriteLine("Testing: " + n);
        BigInteger d = n - 1;
        int s = 0;

        while(d%2==0){
            d/=2;
            s++;
        } //keep taking out powers of 2 until you cant evenly

        //S and D here set  

        

        int i = 0;
        BigInteger y = 0;
        //repeat k times

        using(RandomNumberGenerator rng = RandomNumberGenerator.Create()){
            while(i < k){
                BigInteger a = GenerateRandomBigInteger(rng, 2, n-2); //this function from chatGPT
                BigInteger x = BigInteger.ModPow(a, d, n);

                int i2 = 0;
                //repeat s times
                while(i2 < s){
                    y = BigInteger.ModPow(x, 2, n);

                    //probably composite check 1
                    if(y == 1 && x != 1 && (x != n-1)) return false;

                    x = y;
                    i2++;
                }
                //second composite check
                if(y != 1) return false;


                i++;
            }      
        }   
        
        //probably prime
        return true;
    }


    //From ChatGPT with prompt "How can I generate random BigIntegers in C# between range of int and BigInteger"
    public static BigInteger GenerateRandomBigInteger(RandomNumberGenerator rng, int min, BigInteger max)
    {
        // Convert max to a byte array
        byte[] maxBytes = max.ToByteArray();
        BigInteger result;

        do
        {
            // Generate random bytes and use them to create a BigInteger
            byte[] randomBytes = new byte[maxBytes.Length];
            rng.GetBytes(randomBytes);

            result = new BigInteger(randomBytes);

            // Ensure that the result is within the desired range (min, max)
        } while (result < min || result >= max);

        return result;
    }
}